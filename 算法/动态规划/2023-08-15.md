# 动态规划（1）：2023-08-15

题目目录：

- [斐波那契数列](https://leetcode.cn/problems/fibonacci-number/)
- [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
- [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
- [不同路径](https://leetcode.cn/problems/unique-paths/)
- [不同路径Ⅱ](https://leetcode.cn/problems/unique-paths-ii/)
- [整数拆分](https://leetcode.cn/problems/integer-break/)
- [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

## 斐波那契数列

### 题目示例：

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

**提示：**

- `0 <= n <= 30`

### 思路

本题应该是很基础的题目了，甚至可以说和动态规划没什么关系？但是作为动态规划初学者，当然还是要看成是动态规划来做啦！

### 动态规划

首先最最重要的就是搬出我们的`动规五部曲`了：

1. 确定dp数组以及下标i的含义

   这里dp[i]的定义是第i个数的斐波那契数就是dp[i]。

2. 确定递推公式

   这里的递推公式也就是状态转移方程为 `dp[i] = d[i - 1] + dp[i - 2]`。

3. dp数组如何初始化

   这里初始化是：`dp[0] = 0, dp[1] = 1`。

4. 确定遍历顺序

   从递推公式中我们可以看出来，遍历顺序是从前往后的。

5. 举例推导dp数组

   根据递推公式推导得：i为10的时候，dp[i] = 55。

### 代码

从上面的分析我们就能写出来代码了：

```java
class Solution {
    public int fib(int n) {
        if (n < 2) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

当然我们也可以使用变量代替数组：

```java
class Solution{
	public int fib(int n) {
        if (n == 0 || n == 1) {
            return n;
        }
        int dp_i_1 = 0, dp_i_2 = 1;
        for (int i = 2; i <= n; i++) {
            int sum = dp_i_1 + dp_i_2;
            dp_i_1 = dp_i_2;
            dp_i_2 = sum;
        }
        return dp_i_2;
    }
}
```

## 爬楼梯

### 题目示例：

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：**

- `1 <= n <= 45`

### 思路

本道题看起来是比较难的，但是我们可以推导一下，就可以发现以下规律：

爬到第一层楼梯有一种方法，爬到第二层楼梯有两种方法。

爬到第三层楼梯有三种方法，爬到第四层楼梯有五种方法...

不知道你有没有发现，这不就是类似于斐波那契数列吗！！！

### 动态规划

所以搬出我们的`动规五部曲`吧！

1. 确定dp数组以及下标i的含义

   这里dp[i]的定义是爬到第i层楼梯，有dp[i]种方法。

2. 确定递推公式

   从上面的推到可以看出来，和斐波那契数列相似，所以这里的递推公式也就是状态转移方程为 `dp[i] = d[i - 1] + dp[i - 2]`。

3. dp数组如何初始化

   这里初始化可能会有点抽象，但是请注意看题，n为正整数，所以我们只需要考虑正整数初始化即可，所以初始化就是：`dp[1] = 1, dp[2] = 2`。

4. 确定遍历顺序

   从递推公式中我们可以看出来，遍历顺序是从前往后的。

5. 举例推导dp数组

   根据递推公式推导得：i为5的时候，dp[i] = 8。

### 代码

根据上面的分析，我们可以写出代码如下：

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = d[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

再稍微优化一下：

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int dp_i_1 = 1, dp_i_2 = 2;
        for (int i = 3; i <= n; i++) {
            int sum = dp_i_1 + dp_i_2;
            dp_i_1 = dp_i_2;
            dp_i_2 = sum;
        }
        return dp_i_2;
    }
}
```

## 使用最小花费爬楼梯

### 题目示例：

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

### 思路

看题目是说可以选择从0开始或者从1开始，意思就是说我们到0或者到1是不需要花费费用的，明确这一点之后后面就好理解了。

### 动态规划

`动规五部曲`如下

1. 确定dp数组以及下标i的含义

   这里dp[i]的定义是到达第i个台阶花费的最少体力dp[i]。

2. 确定递推公式

   这里我们需要明确的是有两种方法：从dp[i  - 1]到dp[i]需要花费`dp[i - 1] + cost[i - 1]`，从dp[i  - 2]到dp[i]需要花费`dp[i - 2] + cost[i - 2]`。既然是要求最小费用，那么就是这两个之间取最小值即可：`dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2], cost[i - 2])`。

3. dp数组如何初始化

   我们只需要往最小的去想就行了，所以我们只需要初始化dp[0]和dp[1]即可，但是初始化为多少呢？前面我们说过，到第0和第1个台阶是不花费费用的，那这里就明确了，所以这里初始化是：`dp[0] = 0, dp[1] = 0`。

4. 确定遍历顺序

   从递推公式中我们可以看出来，遍历顺序是从前往后的。

5. 举例推导dp数组

   只需要拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，根据递推公式推导得：到达顶部的时候，最小花费6费用。

### 代码

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length + 1];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.length];
    }
}
```

优化一下：

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int dp0 = 0;
        int dp1 = 0;
        for (int i = 2; i <= cost.length; i++) {
            int dp = Math.min(dp1 + cost[i - 1], dp0 + cost[i - 2]);
            dp0 = dp1;
            dp1 = dp;
        }
        return dp1;
    }
}
```

## 不同路径

### 题目示例：

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![img](./assets/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

### 思路

我们需要将从下边走的路径加上从右边走的路径，因此使用动态规划。机器人从（0, 0）走到（m - 1, n - 1）。

### 动态规划

老规矩，`动规五部曲`如下：

1. 确定dp数组以及下标i的含义

   这里dp[i]的定义是从(0, 0)出发，到达dp[i] [j]的路径条数。

2. 确定递推公式

   我们知道机器人有两种走法，一是向下走，二是向右走，所以从（0, 0）到（m - 1, n - 1）一定会经过（i - 1, j）和（i, j - 1），因此状态转移方程为：`dp[i][j] - dp[i - 1][j] + dp[i][j - 1]`。

3. dp数组如何初始化

   如果i = 0，那就没有意义了，同理j也不能为0，因此我们只能将边界都初始化为1，方便计算，故 `dp[i][0] = 1, dp[0][j] = 1`。

4. 确定遍历顺序

   由递推公式可知，只需要从上到下，从左到右遍历即可。

5. 举例推导dp数组

   可以根据示例中的m = 3，n = 7进行推导。

### 代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

可以进一步优化（个人认为这个优化是比较抽象，有点难理解的）

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return dp[n - 1];
    }
}
```

## 不同路径Ⅱ

这道题和不同路径差不多，只是多了障碍物，区别就在这。

有了障碍物我们应该怎么做呢？当然是绕开障碍物啊！

要记住，在初始化的时候，如果遇到了障碍物，那么后面的就可以不管了，因为根本不会走这里！

然后在遍历的时候，遇到了障碍物也不能算了。因此这道题就直接给出代码了：

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int len1 = obstacleGrid.length;
        int len2 = obstacleGrid[0].length;
        int[][] dp = new int[len1][len2];
        for (int i = 0; i < len1 && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < len2 && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < len1; i++) {
            for (int j = 1; j < len2; j++) {
                if (obstacleGrid[i][j] == 1) {
                    continue;
                }
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[len1 - 1][len2 - 1];
    }
}
```

## 整数拆分

### 题目示例：

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**提示:**

- `2 <= n <= 58`

### 思路

对于正整数 nnn，当 n≥2n \ge 2n≥2 时，可以拆分成至少两个正整数的和。令 xxx 是拆分出的第一个正整数，则剩下的部分是 n−xn-xn−x，n−xn-xn−x 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。

### 动态规划

`动态五部曲`如下：

1. 确定dp数组（dp table）以及下标的含义

   dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

2. 确定递推公式

   可以想 dp[i]最大乘积是怎么得到的呢？其实可以从1遍历j，然后有两种渠道得到dp[i].一个是j * (i - j) 直接相乘（不可拆分）。一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

3. dp的初始化

   严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。拆分0和拆分1的最大乘积是多少？这是无解的。这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！

4. 确定遍历顺序

   确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。所以遍历顺序为：

```cpp
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。

j的结束条件是 j < i - 1 ，其实 j < i 也是可以的，不过可以节省一步，例如让j = i - 1，的话，其实在 j = 1的时候，这一步就已经拆出来了，重复计算，所以 j < i - 1

至于 i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。

更优化一步，可以这样：

```cpp
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j <= i / 2; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。

例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。

只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。

那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。

5. 举例推导dp数组

举例当n为10 的时候，dp数组里的数值

### 代码

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
```

## 不同的二叉搜索树

### 思路

给定一个有序序列 1⋯n1 \cdots n1⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字 iii，将该数字作为树根，将 1⋯(i−1)1 \cdots (i-1)1⋯(i−1) 序列作为左子树，将 (i+1)⋯n(i+1) \cdots n(i+1)⋯n 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。

在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。

由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。

### 动态规划

`动规五部曲`如下：

1. 确定dp数组（dp table）以及下标的含义

   **dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

2. 确定递推公式

   在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]，j相当于是头结点的元素，从1遍历到i为止。所以递推公式：`dp[i] += dp[j - 1] * dp[i - j]; `，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

3. dp数组如何初始化

   初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。那么dp[0]应该是多少呢？从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。所以初始化dp[0] = 1

4. 确定遍历顺序

   首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。那么遍历i里面每一个数作为头结点的状态，用j来遍历。代码如下：

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

5. 举例推导dp数组

   n为5时候的dp数组状态

### 代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];    
            }
        }
        return dp[n];
    }
}
```

